generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Enums for PostgreSQL
enum UserRole {
  ADMIN
  MANAGER
  AGENT
}

enum EstadoCliente {
  NUEVO
  PRIMER_CONTACTO
  EN_TRATATIVAS
  EN_DESARROLLO
  FINALIZADO
  RECONTACTO
}

enum PrioridadCliente {
  BAJA
  MEDIA
  ALTA
  CRITICA
}

enum FuenteCliente {
  IMPORTADO
  MANUAL
  REFERIDO
  CONTACTO_CLIENTE
}

enum TipoActividad {
  LLAMADA
  EMAIL
  REUNION
  TAREA
  NOTA
  PROPUESTA
  SEGUIMIENTO
  CLIENTE_CREADO
  CLIENTE_EDITADO
  CLIENTE_ELIMINADO
  IA_ENRIQUECIMIENTO
  CONTACTO_AUTOMATICO
}

enum CanalContacto {
  EMAIL
  WHATSAPP
}

enum EnrichmentStatusEnum {
  NONE
  PENDING
  PARTIAL
  COMPLETE
}

enum EstadoMensaje {
  PENDIENTE
  ENVIADO
  ERROR
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String?
  emailVerified Boolean        @default(false)
  image         String?
  role          UserRole       @default(AGENT)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // Account lockout fields
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?

  accounts      Account[]
  activities    Actividad[]
  sessions      Session[]
  notifications Notification[]
  plantillas    PlantillaContacto[]
  mensajes      Mensaje[]
  auditLogs     AuditLog[]

  @@index([role])
  @@map("users")
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?   @db.Text
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verifications")
}

model Cliente {
  id              String           @id @default(cuid())
  nombre          String
  email           String?
  telefono        String?
  direccion       String?
  ciudad          String?
  provincia       String?
  codigoPostal    String?
  industria       String?
  fuente          FuenteCliente    @default(MANUAL)
  estado          EstadoCliente    @default(NUEVO)
  prioridad       PrioridadCliente @default(MEDIA)
  fechaCreacion   DateTime         @default(now())
  fechaModific    DateTime         @updatedAt
  ultimoContacto  DateTime?
  notas           String?          @db.Text
  esResponsive    Boolean?
  facebook        String?
  instagram       String?
  linkedin        String?
  sitioWeb        String?
  tieneSSL        Boolean?
  twitter         String?
  whatsapp        String?
  ultimaIA            DateTime?
  enrichmentStatus    EnrichmentStatusEnum @default(NONE)

  // Soft delete
  deletedAt DateTime?

  // Relations
  actividades     Actividad[]
  enrichments     ClienteEnrichment[]
  websiteAnalysis WebsiteAnalysis?
  mensajes        Mensaje[]

  @@index([email])
  @@index([telefono])
  @@index([estado])
  @@index([industria])
  @@index([prioridad])
  @@index([fuente])
  @@index([fechaCreacion])
  @@index([nombre])
  @@index([deletedAt])
  @@index([estado, prioridad])
  @@index([deletedAt, estado])
  @@index([deletedAt, estado, prioridad])
  @@index([enrichmentStatus])
  @@map("clientes")
}

model Actividad {
  id           String        @id @default(cuid())
  tipo         TipoActividad
  descripcion  String        @db.Text
  fecha        DateTime      @default(now())
  clienteId    String
  usuarioId    String
  resultado    String?       @db.Text
  proximoPaso  String?
  esAutomatica Boolean       @default(false)

  // Soft delete
  deletedAt DateTime?

  // Relations
  usuario User    @relation(fields: [usuarioId], references: [id], onDelete: Restrict)
  cliente Cliente @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  @@index([clienteId])
  @@index([usuarioId])
  @@index([tipo])
  @@index([fecha])
  @@index([esAutomatica])
  @@index([deletedAt])
  @@index([clienteId, fecha])
  @@index([usuarioId, fecha])
  @@index([clienteId, deletedAt])
  @@index([deletedAt, clienteId])
  @@map("actividades")
}

// Quota tracking for API rate limiting
model Quota {
  id           String    @id @default(cuid())
  service      String    @unique // screenshots, pagespeed, serpapi, builtwith
  used         Int       @default(0)
  limit        Int
  lastReset    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  successCount Int       @default(0)
  errorCount   Int       @default(0)
  lastError    String?
  lastErrorAt  DateTime?
  // Alert settings
  alertThreshold Int     @default(80) // Percentage to trigger alert
  alertSent      Boolean @default(false)

  history QuotaHistory[]

  @@index([service])
  @@index([lastReset])
  @@map("quotas")
}

// Quota historical tracking
model QuotaHistory {
  id        String   @id @default(cuid())
  quotaId   String
  date      DateTime @db.Date
  used      Int
  success   Int      @default(0)
  errors    Int      @default(0)
  createdAt DateTime @default(now())

  quota Quota @relation(fields: [quotaId], references: [id], onDelete: Cascade)

  @@unique([quotaId, date])
  @@index([quotaId])
  @@index([date])
  @@map("quota_history")
}

// API Keys encriptadas
model ApiKey {
  id         String    @id @default(cuid())
  provider   String    @unique // openai, gemini, grok, deepseek, google_places, etc.
  apiKey     String    @db.Text // Encriptado AES-256
  model      String? // gpt-4o, gemini-1.5-flash, etc.
  enabled    Boolean   @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([provider])
  @@index([enabled])
  @@map("api_keys")
}

// Settings de Enriquecimiento (singleton)
model EnrichmentSettings {
  id String @id @default("default")

  // Parametros IA
  temperature         Float   @default(0.3)
  topP                Float   @default(0.9)
  matchMode           String  @default("fuzzy") // exact, fuzzy, broad
  minConfidenceScore  Float   @default(0.7)
  requireVerification Boolean @default(true)
  maxResultsPerField  Int     @default(3)

  // Toggles analisis website
  enableScreenshots     Boolean @default(true)
  enablePageSpeed       Boolean @default(true)
  enableSsl             Boolean @default(true)
  enableTechStack       Boolean @default(true)
  enableSeo             Boolean @default(true)
  enableAccessibility   Boolean @default(true)
  enableSecurity        Boolean @default(true)
  enableCrawlability    Boolean @default(true)

  updatedAt DateTime @updatedAt

  @@map("enrichment_settings")
}

// Enriquecimiento IA del Cliente (1:N - historial)
model ClienteEnrichment {
  id        String @id @default(cuid())
  clienteId String

  // Datos encontrados
  website          String?
  websiteScore     Float?
  emails           String? @db.Text // JSON
  phones           String? @db.Text // JSON
  address          String?
  addressScore     Float?
  description      String? @db.Text
  descriptionScore Float?
  industry         String?
  industryScore    Float?
  companySize      String?
  companySizeScore Float?
  socialProfiles   String? @db.Text // JSON

  // Metadata
  aiProvidersUsed String?   @db.Text // JSON
  enrichedAt      DateTime?

  // Per-field review status
  fieldStatuses String? @db.Text // JSON: per-field review status (PENDING | CONFIRMED | REJECTED)

  // Review status
  status     String    @default("CONFIRMED") // PENDING | CONFIRMED
  reviewedAt DateTime?
  reviewedBy String?

  cliente Cliente @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  @@index([clienteId])
  @@index([clienteId, enrichedAt])
  @@index([status])
  @@map("cliente_enrichments")
}

// Analisis de Website (1:1)
model WebsiteAnalysis {
  id        String @id @default(cuid())
  clienteId String @unique
  url       String

  // SSL
  sslValid     Boolean?
  sslIssuer    String?
  sslExpiresAt DateTime?
  sslProtocol  String?

  // Performance
  performanceScore Int?
  fcpMs            Int?
  lcpMs            Int?
  ttiMs            Int?
  cls              Float?
  mobileScore      Int?
  desktopScore     Int?

  // Responsive
  hasViewportMeta       Boolean?
  breakpoints           String? @db.Text // JSON
  mediaQueriesCount     Int?
  isResponsive          Boolean?
  responsiveConfidence  String?  // high, medium, low

  // Tech Stack
  techStack String? @db.Text // JSON

  // SEO
  seoTitle        String?
  seoDescription  String? @db.Text
  seoH1Count      Int?
  seoHasCanonical Boolean?
  seoIndexable    Boolean?

  // Structured Data
  hasJsonLd       Boolean?
  jsonLdTypes     String? // JSON
  hasOpenGraph    Boolean?
  openGraphData   String? @db.Text // JSON
  hasTwitterCards Boolean?

  // Accessibility
  accessibilityScore  Int?
  accessibilityIssues String? @db.Text // JSON

  // Security
  hasHttps       Boolean?
  hstsEnabled    Boolean?
  xFrameOptions  String?
  hasCsp         Boolean?
  isSafeBrowsing Boolean?

  // Crawlability
  hasRobotsTxt      Boolean?
  robotsAllowsIndex Boolean?
  hasSitemap        Boolean?
  sitemapUrl        String?
  sitemapUrlCount   Int?

  // Server (IP-API)
  serverLocation String?
  serverIp       String?
  serverIsp      String?
  serverCountry  String?
  serverCity     String?
  isHosting      Boolean?

  // Domain (WhoisXML)
  domainRegistrar  String?
  domainCreatedAt  DateTime?
  domainExpiresAt  DateTime?
  domainAgeYears   Int?
  daysUntilExpiry  Int?
  whoisOwner       String?
  whoisCountry     String?

  // Favicon
  faviconUrl String?

  // Screenshots
  screenshotDesktop String?
  screenshotMobile  String?

  // Metadata
  apisUsed   String?   @db.Text // JSON
  analyzedAt DateTime?

  cliente Cliente @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  @@index([clienteId])
  @@map("website_analyses")
}

// Blob storage tracking for screenshots
model BlobFile {
  id         String   @id @default(cuid())
  url        String   @unique
  pathname   String
  clienteId  String?
  type       String   // desktop_screenshot, mobile_screenshot, other
  size       Int?
  createdAt  DateTime @default(now())

  @@index([clienteId])
  @@index([type])
  @@map("blob_files")
}

// In-app notifications
model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // enrichment_complete, enrichment_failed, bulk_enrichment_complete, etc.
  title     String
  message   String   @db.Text
  link      String?
  metadata  String?  @db.Text // JSON
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

// Plantillas de contacto (email/WhatsApp)
model PlantillaContacto {
  id          String        @id @default(cuid())
  nombre      String
  descripcion String?
  canal       CanalContacto
  asunto      String?       // Solo para EMAIL
  cuerpo      String        @db.Text
  esActiva    Boolean       @default(true)
  creadoPorId String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Soft delete
  deletedAt DateTime?

  creadoPor User      @relation(fields: [creadoPorId], references: [id])
  mensajes  Mensaje[]

  @@index([canal])
  @@index([esActiva])
  @@index([creadoPorId])
  @@index([deletedAt])
  @@map("plantillas_contacto")
}

// Historial de mensajes enviados
model Mensaje {
  id            String        @id @default(cuid())
  canal         CanalContacto
  destinatario  String
  asunto        String?
  cuerpo        String        @db.Text
  estado        EstadoMensaje @default(PENDIENTE)
  errorDetalle  String?       @db.Text
  clienteId     String
  usuarioId     String
  plantillaId   String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Soft delete
  deletedAt DateTime?

  cliente   Cliente            @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  usuario   User               @relation(fields: [usuarioId], references: [id])
  plantilla PlantillaContacto? @relation(fields: [plantillaId], references: [id])

  @@index([clienteId])
  @@index([usuarioId])
  @@index([plantillaId])
  @@index([canal])
  @@index([estado])
  @@index([createdAt])
  @@index([clienteId, createdAt])
  @@index([deletedAt])
  @@map("mensajes")
}

// Audit log for tracking admin actions
model AuditLog {
  id         String   @id @default(cuid())
  action     String
  userId     String
  resource   String
  resourceId String?
  details    String?  @db.Text
  ipAddress  String?
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}
